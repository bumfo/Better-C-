%YAML 1.2
---
# http://www.sublimetext.com/docs/3/syntax.html
name: C++ Next
file_extensions:
  - cc
  - cpp
  - cp
  - cxx
  - c++
  - C
  - h
  - hh
  - hpp
  - hxx
  - h++
  - inl
  - ipp
first_line_match: '-\*- C\+\+(1z)? -\*-'

scope: source.c++1z

variables:
  identifier: '\b[[:alpha:]_][[:alnum:]_]*\b'
  identifier_lookahead: '(?=\b[[:alpha:]_])'

  path_lookahead_optional_content: (?:::\s*)?(?:{{identifier}}\s*::\s*)*
  path_lookahead_content: (?:::\s*)?({{identifier}}\s*::\s*)+
  path_lookahead: '(?={{path_lookahead_content}})'

  path_lookahead_child_optional: (?:::\s*{{identifier}}\s*)*(?:::)?

  scopable_identifier: '{{path_lookahead_optional_content}}{{identifier}}'
  template_item: '[^<>,]*'
  top_level_template_content: '(?:(?:{{template_item}}\s*)(?:,\s*(?:{{template_item}}\s*)?)*)?'
  template_lookahead: |-
    (?x)
    (?:
      (?:<\s*{{top_level_template_content}}>)|
      (?:<\s*
        (?:(?:{{template_item}}\s*)(?:,\s*{{template_item}}\s*)*<\s*)*
        (?:(?:{{template_item}}\s*)(?:,\s*{{template_item}}\s*)*<\s*{{top_level_template_content}}>\s*{{path_lookahead_child_optional}})(?:,\s*(?:{{template_item}}\s*(?:<\s*{{top_level_template_content}}\s*>\s*{{path_lookahead_child_optional}}\s*)?)?)*
      >)
    )
  # basic_types: 'void|char|short|int|long|float|double|signed|unsigned'
  control_keywords: 'break|case|continue|default|do|else|for|goto|if|return|switch|while'

  storage_class_specifiers: 'register|static|thread_local|extern|mutable'
  function_specifiers: 'inline|virtual|explicit'
  decl_specifiers_no_type: '{{storage_class_specifiers}}|{{function_specifiers}}|friend|typedef|constexpr'

  class_specifiers: 'class'
  struct_specifiers: 'struct'
  union_specifiers: 'union'
  enum_specifiers: 'enum'
  cv_qualifiers: 'const|volatile'
  struct_or_union_specifiers: 'struct|union'

  basic_types: 'char|char16_t|char32_t|wchar_t|bool|short|int|long|signed|unsigned|float|double|void|auto'

  function_operators: '(?:new\s*\[\s*\]|delete\s*\[\s*\]|new\b|delete\b|\+=|-=|\*=|/=|%=|^=|&=|\|=|<<|>>|>>=|<<=|==|=|!=|<=|>=|<|>|&&|\|\||\+\+|--|\+|->\*|->|-|\*|/|%|\^|&|\||,|~|!|\(\s*\)|\[\s*\])'
  not_overloadable_operators: '\.|\.\*|\:\:|#|##'
  operators: '{{not_overloadable_operators}}|{{function_operators}}'

contexts:

  prototype:
    - include: comments

  main:
    - include: global

  global:
    - include: preprocessor-others
    - include: using-statements
    - include: global-declars
    - include: statement-groups
    # - scope: punctuation.unmatched
    #   match: '\}'

  using-statements:
    - scope: keyword
      match: '\b(?:using)\b'

  for-statements:
    - scope: keyword.control.for
      match: '\b(?:for)\b'
      push: for-paren

  for-paren-content:
    - scope: punctuation.separator.for
      match: ';'
    - include: expressions
    - scope: punctuation.paren.end
      match: '\)'
      pop: true

  for-paren:
    - scope: punctuation.paren.begin
      match: '\('
      set: [for-paren-content, declar]
    - match: '(?=\S)'
      pop: true

  typeid:
    - scope: storage.type.struct-or-union
      match: '\b(?:{{class_specifiers}}|{{struct_or_union_specifiers}})\b'
      set: [after-typeid, struct-or-union-head]
    - scope: storage.type
      match: '\b(?:{{basic_types}})\b'
      set: after-typeid
    - match: '(?=\S)'
      set: [after-typeid, scoped-maybe-type]

  typenames:
    - scope: storage.type.struct-or-union
      match: '\b(?:{{class_specifiers}}|{{struct_or_union_specifiers}})\b'
      push: [after-typeid, struct-or-union-head]
    - scope: storage.type
      match: '\b(?:{{basic_types}})\b'
      push: after-typeid
    - scope: punctuation
      match: '::'
      push: [after-typeid, scoped-maybe-type-then]
    - match: '(?={{identifier}})'
      push: [after-typeid, scoped-maybe-type-then]

  after-typeid:
    - scope: storage.type.struct-or-union
      match: '\b(?:{{class_specifiers}}|{{struct_or_union_specifiers}})\b'
      set: [after-typeid, struct-or-union-head]
    - scope: storage.modifier.c++
      match: '{{decl_specifiers_no_type}}|{{cv_qualifiers}}'
      set: after-typeid
    - scope: storage.type
      match: '\b(?:{{basic_types}})\b'
      push: after-typeid
    - scope: punctuation
      match: '(?=<)'
      set: [ptr-operator, template-angle-paren]
    - match: '(?=[*&])'
      set: ptr-operator
    - match: '(?=\S)'
      pop: true

  ptr-operator:
    - scope: keyword.pointer
      match: '[*]'
    - scope: keyword.reference.rvalue
      match: '[&]{2}'
    - scope: keyword.reference.lvalue
      match: '[&]'
    - match: '(?=\S)'
      pop: true

  template-angle-paren:
    - scope: punctuation
      match: '<'
      set:
        - include: typenames
        - scope: punctuation
          match: ','
        - scope: punctuation
          match: '>'
          pop: true
        - include: expressions

  scopable:
    - scope: punctuation
      match: '::'
      set: scopable-then
    - match: '(?=\S)'
      set: scopable-then

  scopable-then:
    - scope: meta.identifier.namespace
      match: '{{identifier}}(?=\s*::\s*\b[[:alpha:]_])'
      set:
        - scope: punctuation
          match: '::'
          set: scopable-then
    - match: '(?=\S)'
      pop: true

  scopables:
    - scope: punctuation
      match: '::'
    - scope: meta.identifier.namespace
      match: '{{identifier}}(?=\s*::\s*\b[[:alpha:]_])'
      push:
        - scope: punctuation
          match: '::'
          pop: true

  scoped-maybe-type:
    - scope: punctuation
      match: '::'
      set: scoped-maybe-type-then
    - match: '(?=\S)'
      set: scoped-maybe-type-then

  scoped-maybe-type-then:
    - scope: storage.type.maybe.namespace
      match: '{{identifier}}(?=\s*::\s*\b[[:alpha:]_])'
      set:
        - scope: punctuation
          match: '::'
          set: scoped-maybe-type-then
    - scope: storage.type.maybe
      match: '{{identifier}}'
      pop: true
    - match: '(?=\S)'
      pop: true

  scoped-constructor:
    - scope: punctuation
      match: '::'
      set: scoped-constructor-then
    - match: '(?=\S)'
      set: scoped-constructor-then

  scoped-constructor-then:
    - scope: meta.entity.name.function.constructor.namespace
      match: '{{identifier}}(?=\s*::\s*\b[[:alpha:]_])'
      set:
        - scope: punctuation
          match: '::'
          set: scoped-constructor-then
    - scope: meta.entity.name.function.constructor
      match: '{{identifier}}'
      pop: true
    - match: '(?=\S)'
      pop: true

  entity-name-function-constructor:
    - meta_scope: entity.name.function.constructor
    - match: ''
      pop: true

  scoped-destructor:
    - scope: punctuation
      match: '::'
      set: scoped-destructor-then
    - match: '(?=\S)'
      set: scoped-destructor-then

  scoped-destructor-then:
    - scope: meta.entity.name.function.destructor.namespace
      match: '{{identifier}}(?=\s*::\s*[[:alpha:]_~])'
      set:
        - scope: punctuation
          match: '::'
          set: scoped-destructor-then
    - scope: meta.entity.name.function.destructor
      match: '~'
    - scope: meta.entity.name.function.destructor
      match: '{{identifier}}'
      pop: true
    - match: '(?=\S)'
      pop: true

  entity-name-function-destructor:
    - meta_scope: entity.name.function.destructor
    - match: ''
      pop: true

  global-declars:
    - match: '(?={{path_lookahead_optional_content}}({{identifier}})\s*::\s*\1\s*\s*\()'
      push: [after-parameter-paren, parameter-paren, entity-name-function-constructor, scoped-constructor]
    - scope: entity.name.function.destructor
      match: '(?={{path_lookahead_optional_content}}({{identifier}})\s*::\s*~\s*\1\s*\()'
      push: [after-parameter-paren, parameter-paren, entity-name-function-destructor, scoped-destructor]

    - scope: storage.type.class
      match: '\b(?:{{class_specifiers}})\b'
      push: [global-declar-after-typeid, class-head]
    - scope: storage.type.struct-or-union
      match: '\b(?:{{struct_or_union_specifiers}})\b'
      push: [global-declar-after-typeid, struct-or-union-head]
    - scope: storage.modifier.c++
      match: '{{decl_specifiers_no_type}}|{{cv_qualifiers}}'
      push: [global-declar-after-typeid, typeid]
    - scope: storage.type
      match: '\b(?:{{basic_types}})\b'
      push: global-declar-after-typeid
    - scope: storage.type.maybe
      match: '(?={{scopable_identifier}}\s*(?:[*&]\s*)*(\((?:[*&]\s*)*)?\b[[:alpha:]_])'
      push: [global-declar-after-typeid, scoped-maybe-type]
    - scope: storage.type.maybe
      match: '(?={{scopable_identifier}}\s*{{template_lookahead}})'
      push: [global-declar-after-typeid, scoped-maybe-type]

  declars:
    - scope: storage.type.class
      match: '\b(?:{{class_specifiers}})\b'
      push: [declar-after-typeid, class-head]
    - scope: storage.type.struct-or-union
      match: '\b(?:{{struct_or_union_specifiers}})\b'
      push: [declar-after-typeid, struct-or-union-head]
    - scope: storage.modifier.c++
      match: '{{decl_specifiers_no_type}}|{{cv_qualifiers}}'
      push: [declar-after-typeid, typeid]
    - scope: storage.type
      match: '\b(?:{{basic_types}})\b'
      push: declar-after-typeid
    - scope: storage.type.maybe
      match: '(?={{scopable_identifier}}\s*(?:[*&]\s*)*(\((?:[*&]\s*)*)?\b[[:alpha:]_])'
      push: [declar-after-typeid, scoped-maybe-type]
    - scope: storage.type.maybe
      match: '(?={{scopable_identifier}}\s*{{template_lookahead}})'
      push: [declar-after-typeid, scoped-maybe-type]

  declar:
    - scope: storage.type.class
      match: '\b(?:{{class_specifiers}})\b'
      set: [declar-after-typeid, class-head]
    - scope: storage.type.struct-or-union
      match: '\b(?:{{struct_or_union_specifiers}})\b'
      set: [declar-after-typeid, struct-or-union-head]
    - scope: storage.modifier.c++
      match: '{{decl_specifiers_no_type}}|{{cv_qualifiers}}'
      set: [declar-after-typeid, typeid]
    - scope: storage.type
      match: '\b(?:{{basic_types}})\b'
      set: declar-after-typeid
    - scope: storage.type.maybe
      match: '(?={{scopable_identifier}}\s*(?:[*&]\s*)*(\((?:[*&]\s*)*)?\b[[:alpha:]_])'
      set: [declar-after-typeid, scoped-maybe-type]
    - scope: storage.type.maybe
      match: '(?={{scopable_identifier}}\s*{{template_lookahead}})'
      set: [declar-after-typeid, scoped-maybe-type]
    - match: '(?=\S)'
      pop: true

  scoped-function-variable:
    - scope: punctuation
      match: '::'
      set: scoped-function-variable-then
    - match: '(?=\S)'
      set: scoped-function-variable-then

  scoped-function-variable-then:
    - scope: variable.function.namespace
      match: '{{identifier}}(?=\s*::\s*\b[[:alpha:]_])'
      set:
        - scope: punctuation
          match: '::'
          set: scoped-function-variable-then
    - scope: variable.function
      match: '{{identifier}}'
      pop: true
    - match: '(?=\S)'
      pop: true

  free-identifiers:
    - scope: keyword
      match: '\b(?:operator)\b'
      push: [argument-paren, operator-variable-function-name]
    - match: '(?={{scopable_identifier}}\s*\()'
      push: [argument-paren, scoped-function-variable]
    - match: '(?={{scopable_identifier}}\s*{{template_lookahead}}\s*\()'
      push: [argument-paren, template-angle-paren, scoped-function-variable]

  argument-paren:
    - scope: punctuation
      match: '\('
      set: 
        - scope: punctuation.separator
          match: ','
        - include: expressions
        - scope: punctuation
          match: '\)'
          pop: true

  declar-after-typeid:
    - match: ''
      set: [noptr-declarator, after-typeid]

  global-declar-after-typeid:
    - match: ''
      set: [global-noptr-declarator, after-typeid]

  ptr-declarators:
    - match: '(?=[*&])'
      push: ptr-operator
    - include: noptr-declarators

  operator-variable-function-name:
    - scope: variable.function.operator
      match: '{{function_operators}}'
      pop: true
    - match: '(?=\S)'
      pop: true

  operator-entity-function-name:
    - scope: meta.entity.name.function.operator
      match: '{{function_operators}}'
      pop: true
    - match: '(?=\S)'
      pop: true

  scoped-entity-name-function:
    - scope: punctuation
      match: '::'
      set: scoped-entity-name-function-then
    - match: '(?=\S)'
      set: scoped-entity-name-function-then

  scoped-entity-name-function-then:
    - scope: meta.entity.name.function.namespace
      match: '{{identifier}}(?=\s*::\s*\b[[:alpha:]_])'
      set:
        - scope: punctuation
          match: '::'
          set: scoped-entity-name-function-then
    - scope: keyword
      match: '\b(?:operator)\b'
      set:
        - scope: meta.entity.name.function.operator
          match: '{{function_operators}}'
          pop: true
        - match: '(?=\S)'
          pop: true
      # set: operator-entity-function-name
    - scope: meta.entity.name.function
      match: '{{identifier}}'
      pop: true
    - match: '(?=\S)'
      pop: true


  global-declarator-id:
    - scope: keyword
      match: '\b(?:operator)\b'
      set: [global-after-declarator-initializer, parameter-paren, entity-name-function-operator, operator-entity-function-name]
    - scope: entity.name.function
      match: '{{identifier}}(?=\s*\()'
      set: [global-after-declarator-initializer, parameter-paren]
    - scope: meta.identifier.global
      match: '{{identifier}}'
      set: global-after-declarator

  entity-name-function-operator:
    - meta_scope: entity.name.function.operator
    - match: ''
      pop: true

  entity-name-function:
    - meta_scope: entity.name.function
    - match: ''
      pop: true

  global-noptr-declarator:
    - include: statement-terminator
    - match: '(?={{path_lookahead_content}}(?:\b(?:operator)\b\s*{{function_operators}})(?:\s*\())'
      set: [global-after-declarator-initializer, parameter-paren, entity-name-function-operator, scoped-entity-name-function]
    - match: '(?={{path_lookahead_content}}(?:{{identifier}})(?:\s*\())'
      set: [global-after-declarator-initializer, parameter-paren, entity-name-function, scoped-entity-name-function]
    - include: global-declarator-id
    - scope: punctuation
      match: '\('
      set:
        - include: ptr-declarators
        - scope: punctuation
          match: '\)'
          set: global-after-declarator
    - match: '(?=\S)'
      pop: true

  noptr-declarator:
    - include: statement-terminator
    - scope: keyword
      match: '\b(?:operator)\b'
      set: [after-declarator-initializer, parameter-paren, entity-name-function-operator, operator-entity-function-name]
    - scope: entity.name.function
      match: '{{identifier}}(?=\s*\(\))'
      set: [after-declarator-initializer, parameter-paren]
    - scope: meta.identifier
      match: '{{identifier}}'
      set: after-declarator
    - scope: punctuation
      match: '\('
      set:
        - include: ptr-declarators
        - scope: punctuation
          match: '\)'
          set: after-declarator
    - match: '(?=\S)'
      pop: true

  noptr-declarators:
    - scope: entity.name.function
      match: '{{identifier}}(?=\s*\()'
      push: [after-declarator-initializer, parameter-paren]
    - scope: meta.identifier
      match: '{{identifier}}'
      push: after-declarator
    - match: '\('
      push:
        - include: ptr-declarators
        - match: '\)'
          set: after-declarator

  declar-separator:
    - scope: punctuation.separator
      match: ','
      set: [noptr-declarator, ptr-operator]

  param-declar-separator:
    - scope: punctuation.separator
      match: ','
      pop: true

  param-after-typeid:
    - match: ''
      set: [param-noptr-declarator, after-typeid]

  param-ptr-declarators:
    - match: '(?=[*&])'
      push: ptr-operator
    - include: param-noptr-declarators

  param-noptr-declarator:
    - include: param-declar-separator
    - scope: variable.parameter.function
      match: '{{identifier}}(?=\s*\()'
      set: [param-after-declarator, parameter-paren]
    - scope: variable.parameter
      match: '{{identifier}}'
      set: param-after-declarator
    - scope: punctuation
      match: '\('
      set:
        - include: param-ptr-declarators
        - scope: punctuation
          match: '\)'
          set: param-after-declarator
    - match: '(?=\S)'
      pop: true

  param-noptr-declarators:
    - scope: variable.parameter.function
      match: '{{identifier}}(?=\s*\()'
      push: [param-after-declarator, parameter-paren]
    - scope: variable.parameter
      match: '{{identifier}}'
      push: param-after-declarator
    - match: '\('
      push:
        - include: param-ptr-declarators
        - match: '\)'
          set: param-after-declarator

  param-after-noptr-declarator:
    - include: param-declar-separator
    - include: statement-terminator
    - scope: keyword.operator
      match: '='
      set: 
        - include: param-declar-separator
        - include: statement-terminator
        - include: expressions
    - match: '(?=\S)'
      pop: true

  param-after-declarator:
    - match: '(?=\()'
      set: [param-after-declarator, parameter-paren]
    - scope: punctuation
      match: '\['
      set:
        - include: expressions
        - scope: punctuation
          match: '\]'
          set: param-after-declarator
    - match: '(?=\S)'
      set: param-after-noptr-declarator

  param-typenames:
    - scope: storage.type.struct-or-union
      match: '\b(?:{{class_specifiers}}|{{struct_or_union_specifiers}})\b'
      push: [param-after-typeid, struct-or-union-head]
    - scope: storage.modifier.c++
      match: '{{decl_specifiers_no_type}}|{{cv_qualifiers}}'
      push: [param-after-typeid, typeid]
    - scope: storage.type
      match: '\b(?:{{basic_types}})\b'
      push: param-after-typeid
    - scope: storage.type.maybe
      match: '(?={{scopable_identifier}}\s*)'
      push: [param-after-typeid, scoped-maybe-type]

  parameter-paren:
    - scope: punctuation
      match: '\('
      set:
        - include: param-typenames
        - scope: punctuation
          match: '\)'
          pop: true
        # - match: '(?=\S)'
        #   pop: true
    - match: '(?=\S)'
      pop: true

  parameter-parens:
    - match: '(?=\()'
      push: parameter-paren

  # after-declarator-initializer:
  #   - include: declar-separator
  #   - include: statement-terminator

  after-declarator-initializer:
    - include: declar-separator
    - include: statement-terminator
    - match: '(?=\S)'
      pop: true

  after-declarator-common:
    - scope: keyword.operator
      match: '='
      set: 
        - include: brace-initializer
        - include: declar-separator
        - include: statement-terminator
        - include: expressions
    - include: after-declarator-initializer
    # - match: '(?=\S)'
    #   pop: true

  initializer-argument-contents:
    - scope: punctuation.separator
      match: ','
    - include: expressions

  after-declarator:
    - match: '(?=\(\))'
      set: [after-declarator-initializer, parameter-paren]
    - scope: punctuation
      match: '\['
      set:
        - include: expressions
        - scope: punctuation
          match: '\]'
          set: after-declarator
    - match: '(?=\{)'
      set: [after-declarator-initializer, brace-initializer]
    - match: '(?=\()'
      set: [after-declarator-initializer, parens-initilizer]
    - include: after-declarator-common

  parens-initilizer:
    - scope: punctuation.parens.initializer
      match: '\('
      set:
        - include: initializer-argument-contents
        - scope: punctuation.parens.initializer
          match: '\)'
          pop: true

  brace-initializers:
    - match: '(?=\{)'
      push: brace-initializer

  brace-initializer:
    - scope: punctuation.braces.initializer
      match: '\{'
      set:
        - include: brace-initializers
        - include: initializer-argument-contents
        - scope: punctuation.braces.initializer
          match: '\}'
          pop: true

  global-after-declarator-initializer:
    - include: declar-separator
    - include: statement-terminator
    - match: '(?=\S)'
      pop: true

  global-after-declarator:
    - match: '(?=\()'
      set: [global-after-declarator-initializer, parameter-paren]
    - scope: punctuation
      match: '\['
      set:
        - include: expressions
        - scope: punctuation
          match: '\]'
          set: global-after-declarator
    - match: '(?=\{)'
      set: [global-after-declarator-initializer, brace-initializer]
    - match: '(?=\()'
      set: [global-after-declarator-initializer, parens-initilizer]
    - include: after-declarator-common

  statement-terminator:
    - scope: punctuation
      match: ';'
      pop: true


  statements:
    - include: for-statements
    - scope: keyword.control
      match: '\b(?:{{control_keywords}})\b'
    - include: free-identifiers
    - include: declars
    - include: expr-groups
    - include: statement-groups
    - include: expressions
    - scope: punctuation.terminator
      match: ';'

  statement-group:
    - scope: punctuation
      match: '\{'
      set:
        - include: statements
        - scope: punctuation
          match: '\}'
          pop: true

  statement-groups:
    - match: '(?=\{)'
      push: statement-group

  expressions:
    - include: strings
    - include: numbers
    - include: expr-groups
    - include: free-identifiers
    - scope: punctuation
      match: '\['
      push:
        - include: expressions
        - scope: punctuation
          match: '\]'
          pop: true
    - scope: keyword.operator
      match: '{{operators}}'
    - scope: keyword.operator.comma
      match: ','

  expr-group:
    - scope: punctuation
      match: '\('
      set:
        - include: expressions
        - scope: punctuation
          match: '\)'
          pop: true

  expr-groups:
    - match: '(?=\()'
      push: expr-group


  class-head-name:
    # - meta_scope: entity.name.function
    - scope: entity.name.class
      match: ({{identifier}})
      set: [class-constructor-name, test, class-open-brace]
    - match: '(?=\S)'
      pop: true

  class-open-brace:
    - scope: punctuation
      match: '\{'
      pop: true

  after-parameter-paren:
    - scope: punctuation
      match: ';'
      pop: true
    - include: statement-group
    - match: '(?=\S)'
      pop: true

  class-constructor-name:
    - scope: punctuation
      match: '\}'
      pop: true
    - scope: entity.name.function.destructor
      match: (?<=\~)({{identifier}})
      set: [class-constructor-name, test, after-parameter-paren, parameter-paren]
    - scope: entity.name.function.constructor
      match: ({{identifier}})
      set: [class-constructor-name, test, after-parameter-paren, parameter-paren]
    - match: '(?=\S)'

  class-modifiers:
    - scope: storage.modifier.c++
      match: '\b(?:public|private|protected)\b'
      push:
        - scope: punctuation
          match: ':'
          pop: true
        - match: '(?=\S)'
          pop: true

  test:
    - include: statement-groups
    - match: '(?=\})'
      pop: true
    - scope: entity.name.function.destructor
      match: '~(?=\b\1\s*\()'
      pop: true
    - scope: entity.name.function.constructor
      match: (?=\b\1\s*\()
      pop: true
    - include: class-modifiers
    - include: global-declars

  class-head:
    - include: class-head-name
    - match: '(?=\S)'
      pop: true

  struct-or-union-head:
    - scope: entity.name.struct-or-union
      match: '({{identifier}})'
      set: class-or-struct-or-union-body
    - match: '(?=\S)'
      set: class-or-struct-or-union-body

  class-or-struct-or-union-body:
    - scope: punctuation
      match: '\{'
      set:
        - include: class-modifiers
        - include: declars
        - scope: punctuation
          match: '\}'
          pop: true
    - match: '(?=\S)'
      pop: true

  constructors-or-destructors:
    - scope: entity.name.function.constructor
      match: '\1'










  comments:
    - scope: comment.block.c++
      match: '^/\* =(\s*.*?)\s*= \*/$\n?'
      captures:
        1: meta.toc-list.banner.block.c++
    - scope: punctuation.definition.comment.c++
      match: '/\*'
      push:
        - meta_scope: comment.block.c++
        - scope: punctuation.definition.comment.c++
          match: '\*/'
          pop: true
    - scope: invalid.illegal.stray-comment-end.c++
      match: '\*/(?!\*)'
    - scope: comment.line.banner.c++
      match: '^// =(\s*.*?)\s*=\s*$\n?'
      captures:
        1: meta.toc-list.banner.line.c++
    - scope: punctuation.definition.comment.c++
      match: '//'
      push:
        - meta_scope: comment.line.double-slash.c++
        - match: '(\\)$\n'
          captures:
            1: punctuation.separator.continuation.c++
        - match: '(?=\n)'
          pop: true


  strings:
    - include: unique-strings
    - include: c-strings

  numbers:
    - include: unique-numbers
    - match: '\b((0(x|X)[0-9a-fA-F]*(\.[0-9a-fA-F]+p-?\d+)?)|(([0-9]+\.?[0-9]*)|(\.[0-9]+))((e|E)(\+|-)?[0-9]+)?)(L|l|UL|ul|u|U|F|f|ll|LL|ull|ULL)?\b'
      scope: constant.numeric.c++



  c-strings:
    - match: '(L|u8|u|U)?(")'
      captures:
        1: storage.type.string.c
        2: punctuation.definition.string.begin.c
      push:
        - meta_scope: string.quoted.double.c
        - match: '"'
          scope: punctuation.definition.string.end.c
          pop: true
        - include: string_escaped_char
        - include: string_placeholder
    - match: "(L|u8|u|U)?(')"
      captures:
        1: storage.type.string.c
        2: punctuation.definition.string.begin.c
      push:
        - meta_scope: string.quoted.single.c
        - match: "'"
          scope: punctuation.definition.string.end.c
          pop: true
        - include: string_escaped_char

  string_escaped_char:
    - match: '(\\)$\n'
      captures:
        1: punctuation.separator.continuation.c
    - match: \\(?:\\|[abefnrtv\'"?]|[0-3][0-9]{0,2}|[4-7][0-9]?|x[a-fA-F0-9]+|u[a-fA-F0-9]{4}|U[a-fA-F0-9]{8})
      scope: constant.character.escape.c
    - match: \\.
      scope: invalid.illegal.unknown-escape.c

  string_placeholder:
    - match: |-
        (?x)%
          (\d+\$)?                                      # field (argument #)
          [#0\- +']*                                    # flags
          [,;:_]?                                       # separator character (AltiVec)
          ((-?\d+)|\*(-?\d+\$)?)?                       # minimum field width
          (\.((-?\d+)|\*(-?\d+\$)?)?)?                  # precision
          (hh|h|ll|l|j|t|z|q|L|vh|vl|v|hv|hl)?          # length modifier
          (\[[^\]]+\]|[am]s|[diouxXDOUeEfFgGaACcSspn%]) # conversion type
      scope: constant.other.placeholder.c
    - match: "%"
      scope: invalid.illegal.placeholder.c




  preprocessor-others:
    - match: ^\s*(#\s*(?:if|ifdef|ifndef|elif|else|line|pragma|undef))\b
      captures:
        1: keyword.control.import.c++
      push:
        - meta_scope: meta.preprocessor.c++
        - include: scope:source.c#preprocessor-line-continuation
        - include: scope:source.c#preprocessor-line-ending
        - include: scope:source.c#preprocessor-comments
        - match: \bdefined\b
          scope: keyword.control.c++
    - match: ^\s*(#\s*endif)\b
      captures:
        1: meta.preprocessor.c++ keyword.control.import.c++
    - match: ^\s*(#\s*(?:error|warning))\b
      captures:
        1: keyword.control.import.error.c++
      push:
        - meta_scope: meta.preprocessor.diagnostic.c++
        - include: scope:source.c#preprocessor-line-continuation
        - include: scope:source.c#preprocessor-line-ending
        - include: scope:source.c#preprocessor-comments
        - include: strings
        - match: '\S+'
          scope: string.unquoted.c++
    - match: ^\s*(#\s*(?:include|import))\b\s*
      captures:
        1: keyword.control.import.include.c++
      push:
        - meta_scope: meta.preprocessor.include.c++
        - include: scope:source.c#preprocessor-line-continuation
        - include: scope:source.c#preprocessor-line-ending
        - include: scope:source.c#preprocessor-comments
        - match: '"'
          scope: punctuation.definition.string.begin.c++
          push:
            - meta_scope: string.quoted.double.include.c++
            - match: '"'
              scope: punctuation.definition.string.end.c++
              pop: true
        - match: <
          scope: punctuation.definition.string.begin.c++
          push:
            - meta_scope: string.quoted.other.lt-gt.include.c++
            - match: '>'
              scope: punctuation.definition.string.end.c++
              pop: true
