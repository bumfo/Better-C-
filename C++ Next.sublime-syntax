%YAML 1.2
---
# http://www.sublimetext.com/docs/3/syntax.html
name: C++ Next
file_extensions:
  - cc
  - cpp
  - cp
  - cxx
  - c++
  - C
  - h
  - hh
  - hpp
  - hxx
  - h++
  - inl
  - ipp
first_line_match: '-\*- C\+\+(1z)? -\*-'

scope: source.c++1z

variables:
  identifier: '\b[[:alpha:]_][[:alnum:]_]*\b'
  identifier_lookahead: '(?=\b[[:alpha:]_])'
  scopable_identifier: '(?:::\s*)?({{identifier}}\s*::\s*)*{{identifier}}'
  top_level_template_content: (?:(?:{{scopable_identifier}}\s*)(?:,\s*(?:{{scopable_identifier}}\s*)?)*)?
  template_lookahead: |-
    (?x)
    (?:
      (?:<\s*{{top_level_template_content}}>)|
      (?:<\s*
        (?:(?:{{scopable_identifier}}\s*)(?:,\s*{{scopable_identifier}}\s*)*<\s*)*
        (?:(?:{{scopable_identifier}}\s*)(?:,\s*{{scopable_identifier}}\s*)*<\s*{{top_level_template_content}}>\s*)(?:,\s*(?:{{scopable_identifier}}\s*(?:<\s*{{top_level_template_content}}>\s*)?)?)*
      >)
    )
  # basic_types: 'void|char|short|int|long|float|double|signed|unsigned'
  control_keywords: 'break|case|continue|default|do|else|for|goto|if|return|switch|while'

  storage_class_specifier: 'register|static|thread_local|extern|mutable'
  function_specifier: 'inline|virtual|explicit'
  decl_specifier_no_type: '{{storage_class_specifier}}|{{function_specifier}}|friend|typedef|constexpr'

  class_specifier: 'class|struct'
  union_specifier: 'union'
  enum_specifier: 'enum'
  cv_qualifier: 'const|volatile'

  basic_types: 'char|char16_t|char32_t|wchar_t|bool|short|int|long|signed|unsigned|float|double|void|auto'

contexts:

  prototype:
    - include: comments

  main:
    - include: global

  global:
    - include: preprocessor-others
    - include: declars
    - include: statement-groups
    # - scope: punctuation.unmatched
    #   match: '\}'

  typeid:
    - scope: storage.type
      match: '\b(?:{{basic_types}})\b'
      set: after-typeid
    - match: '(?=\S)'
      set: [after-typeid, scoped-maybe-type]

  typenames:
    - scope: storage.type
      match: '\b(?:{{basic_types}})\b'
      push: after-typeid
    - scope: punctuation
      match: '::'
      push: [after-typeid, scoped-maybe-type-then]
    - match: '(?={{identifier}})'
      push: [after-typeid, scoped-maybe-type-then]

  after-typeid:
    - scope: storage.modifier.c++
      match: '{{decl_specifier_no_type}}|{{cv_qualifier}}'
      set: after-typeid
    - scope: storage.type
      match: '\b(?:{{basic_types}})\b'
      push: after-typeid
    - scope: punctuation
      match: '(?=<)'
      set: [ptr-operator, template-angle-paren]
    - match: '(?=[*&])'
      set: ptr-operator
    - match: '(?=\S)'
      pop: true

  ptr-operator:
    - scope: keyword.pointer
      match: '[*]'
    - scope: keyword.reference.rvalue
      match: '[&]{2}'
    - scope: keyword.reference.lvalue
      match: '[&]'
    - match: '(?=\S)'
      pop: true

  template-angle-paren:
    - scope: punctuation
      match: '<'
      set:
        - include: typenames
        - scope: punctuation
          match: ','
        - scope: punctuation
          match: '>'
          pop: true

  scopable:
    - scope: punctuation
      match: '::'
      set: scopable-then
    - match: '(?=\S)'
      set: scopable-then

  scopable-then:
    - scope: meta.identifier.namespace
      match: '{{identifier}}(?=\s*::\s*\b[[:alpha:]_])'
      set:
        - scope: punctuation
          match: '::'
          set: scopable-then
    - match: '(?=\S)'
      pop: true

  scopables:
    - scope: punctuation
      match: '::'
    - scope: meta.identifier.namespace
      match: '{{identifier}}(?=\s*::\s*\b[[:alpha:]_])'
      push:
        - scope: punctuation
          match: '::'
          pop: true

  scoped-maybe-type:
    - scope: punctuation
      match: '::'
      set: scoped-maybe-type-then
    - match: '(?=\S)'
      set: scoped-maybe-type-then

  scoped-maybe-type-then:
    - scope: storage.type.maybe.namespace
      match: '{{identifier}}(?=\s*::\s*\b[[:alpha:]_])'
      set:
        - scope: punctuation
          match: '::'
          set: scoped-maybe-type
    - scope: storage.type.maybe
      match: '{{identifier}}'
      pop: true
    - match: '(?=\S)'
      pop: true

  declars:
    - scope: storage.modifier.c++
      match: '{{decl_specifier_no_type}}|{{cv_qualifier}}'
      push: [declar-after-typeid, typeid]
    - scope: storage.type
      match: '\b(?:{{basic_types}})\b'
      push: declar-after-typeid
    - scope: storage.type.maybe
      match: '(?={{scopable_identifier}}\s*(?:[*&]\s*)*(\((?:[*&]\s*)*)?\b[[:alpha:]_])'
      push: [declar-after-typeid, scoped-maybe-type]
    - scope: storage.type.maybe
      match: '(?={{scopable_identifier}}\s*{{template_lookahead}})'
      push: [declar-after-typeid, scoped-maybe-type]

  scoped-function-variable:
    - scope: punctuation
      match: '::'
      set: scoped-function-variable-then
    - match: '(?=\S)'
      set: scoped-function-variable-then

  scoped-function-variable-then:
    - scope: variable.function.namespace
      match: '{{identifier}}(?=\s*::\s*\b[[:alpha:]_])'
      set:
        - scope: punctuation
          match: '::'
          set: scoped-function-variable-then
    - scope: variable.function
      match: '{{identifier}}'
      pop: true
    - match: '(?=\S)'
      pop: true

  free-identifiers:
    - match: '(?={{scopable_identifier}}\s*\()'
      push: [argument-paren, scoped-function-variable]
    - match: '(?={{scopable_identifier}}\s*{{template_lookahead}}\s*\()'
      push: [argument-paren, template-angle-paren, scoped-function-variable]

  argument-paren:
    - scope: punctuation
      match: '\('
      set: 
        - scope: punctuation.separator
          match: ','
        - include: expressions
        - scope: punctuation
          match: '\)'
          pop: true

  declar-after-typeid:
    - match: ''
      set: [noptr-declarator, after-typeid]

  ptr-declarators:
    - match: '(?=[*&])'
      push: ptr-operator
    - include: noptr-declarators

  noptr-declarator:
    - include: statement-terminator
    - scope: entity.name.function
      match: '{{identifier}}(?=\s*\()'
      set: [after-declarator, parameter-paren]
    - scope: meta.identifier
      match: '{{identifier}}'
      set: after-declarator
    - scope: punctuation
      match: '\('
      set:
        - include: ptr-declarators
        - scope: punctuation
          match: '\)'
          set: after-declarator
    - match: '(?=\S)'
      pop: true

  noptr-declarators:
    - scope: entity.name.function
      match: '{{identifier}}(?=\s*\()'
      push: [after-declarator, parameter-paren]
    - scope: meta.identifier
      match: '{{identifier}}'
      push: after-declarator
    - match: '\('
      push:
        - include: ptr-declarators
        - match: '\)'
          set: after-declarator

  after-noptr-declarator:
    - include: declar-separator
    - include: statement-terminator
    - scope: keyword.operator
      match: '='
      set: 
        - include: declar-separator
        - include: statement-terminator
        - include: expressions
    - match: '(?=\S)'
      pop: true

  declar-separator:
    - scope: punctuation.separator
      match: ','
      set: [noptr-declarator, ptr-operator]

  parameter-paren:
    - scope: punctuation
      match: '\('
      set:
        - scope: punctuation
          match: '\)'
          pop: true
        # - match: '(?=\S)'
        #   pop: true
    - match: '(?=\S)'
      pop: true

  parameter-parens:
    - match: '(?=\()'
      push: parameter-paren

  after-declarator:
    - match: '(?=\()'
      set: [after-declarator, parameter-paren]
    - scope: punctuation
      match: '\['
      set:
        - include: expressions
        - scope: punctuation
          match: '\]'
          set: after-declarator
    - match: '(?=\S)'
      set: after-noptr-declarator

  statement-terminator:
    - scope: punctuation
      match: ';'
      pop: true



  statements:
    - scope: keyword.control
      match: '\b(?:{{control_keywords}})\b'
    - include: free-identifiers
    - include: declars
    - include: expr-groups
    - include: statement-groups
    - include: expressions

  statement-group:
    - scope: punctuation
      match: '\{'
      set:
        - include: statements
        - scope: punctuation
          match: '\}'
          pop: true

  statement-groups:
    - match: '(?=\{)'
      push: statement-group

  expressions:
    - include: strings
    - include: numbers
    - include: expr-groups
    - include: free-identifiers
    - scope: keyword.comma
      match: ','

  expr-group:
    - scope: punctuation
      match: '\('
      set:
        - include: expressions
        - scope: punctuation
          match: '\)'
          pop: true

  expr-groups:
    - match: '(?=\()'
      push: expr-group
















  comments:
    - scope: comment.block.c++
      match: ^/\* =(\s*.*?)\s*= \*/$\n?
      captures:
        1: meta.toc-list.banner.block.c++
    - scope: punctuation.definition.comment.c++
      match: /\*
      push:
        - meta_scope: comment.block.c++
        - scope: punctuation.definition.comment.c++
          match: \*/
          pop: true
    - scope: invalid.illegal.stray-comment-end.c++
      match: \*/(?!\*)
    - scope: comment.line.banner.c++
      match: ^// =(\s*.*?)\s*=\s*$\n?
      captures:
        1: meta.toc-list.banner.line.c++
    - scope: punctuation.definition.comment.c++
      match: //
      push:
        - meta_scope: comment.line.double-slash.c++
        - match: '(\\)$\n'
          captures:
            1: punctuation.separator.continuation.c++
        - match: (?=\n)
          pop: true


  strings:
    - include: unique-strings
    - include: c-strings

  numbers:
    - include: unique-numbers
    - match: '\b((0(x|X)[0-9a-fA-F]*(\.[0-9a-fA-F]+p-?\d+)?)|(([0-9]+\.?[0-9]*)|(\.[0-9]+))((e|E)(\+|-)?[0-9]+)?)(L|l|UL|ul|u|U|F|f|ll|LL|ull|ULL)?\b'
      scope: constant.numeric.c++



  c-strings:
    - match: '(L|u8|u|U)?(")'
      captures:
        1: storage.type.string.c
        2: punctuation.definition.string.begin.c
      push:
        - meta_scope: string.quoted.double.c
        - match: '"'
          scope: punctuation.definition.string.end.c
          pop: true
        - include: string_escaped_char
        - include: string_placeholder
    - match: "(L|u8|u|U)?(')"
      captures:
        1: storage.type.string.c
        2: punctuation.definition.string.begin.c
      push:
        - meta_scope: string.quoted.single.c
        - match: "'"
          scope: punctuation.definition.string.end.c
          pop: true
        - include: string_escaped_char

  string_escaped_char:
    - match: '(\\)$\n'
      captures:
        1: punctuation.separator.continuation.c
    - match: \\(?:\\|[abefnrtv\'"?]|[0-3][0-9]{0,2}|[4-7][0-9]?|x[a-fA-F0-9]+|u[a-fA-F0-9]{4}|U[a-fA-F0-9]{8})
      scope: constant.character.escape.c
    - match: \\.
      scope: invalid.illegal.unknown-escape.c

  string_placeholder:
    - match: |-
        (?x)%
          (\d+\$)?                                      # field (argument #)
          [#0\- +']*                                    # flags
          [,;:_]?                                       # separator character (AltiVec)
          ((-?\d+)|\*(-?\d+\$)?)?                       # minimum field width
          (\.((-?\d+)|\*(-?\d+\$)?)?)?                  # precision
          (hh|h|ll|l|j|t|z|q|L|vh|vl|v|hv|hl)?          # length modifier
          (\[[^\]]+\]|[am]s|[diouxXDOUeEfFgGaACcSspn%]) # conversion type
      scope: constant.other.placeholder.c
    - match: "%"
      scope: invalid.illegal.placeholder.c




  preprocessor-others:
    - match: ^\s*(#\s*(?:if|ifdef|ifndef|elif|else|line|pragma|undef))\b
      captures:
        1: keyword.control.import.c++
      push:
        - meta_scope: meta.preprocessor.c++
        - include: scope:source.c#preprocessor-line-continuation
        - include: scope:source.c#preprocessor-line-ending
        - include: scope:source.c#preprocessor-comments
        - match: \bdefined\b
          scope: keyword.control.c++
    - match: ^\s*(#\s*endif)\b
      captures:
        1: meta.preprocessor.c++ keyword.control.import.c++
    - match: ^\s*(#\s*(?:error|warning))\b
      captures:
        1: keyword.control.import.error.c++
      push:
        - meta_scope: meta.preprocessor.diagnostic.c++
        - include: scope:source.c#preprocessor-line-continuation
        - include: scope:source.c#preprocessor-line-ending
        - include: scope:source.c#preprocessor-comments
        - include: strings
        - match: '\S+'
          scope: string.unquoted.c++
    - match: ^\s*(#\s*(?:include|import))\b\s*
      captures:
        1: keyword.control.import.include.c++
      push:
        - meta_scope: meta.preprocessor.include.c++
        - include: scope:source.c#preprocessor-line-continuation
        - include: scope:source.c#preprocessor-line-ending
        - include: scope:source.c#preprocessor-comments
        - match: '"'
          scope: punctuation.definition.string.begin.c++
          push:
            - meta_scope: string.quoted.double.include.c++
            - match: '"'
              scope: punctuation.definition.string.end.c++
              pop: true
        - match: <
          scope: punctuation.definition.string.begin.c++
          push:
            - meta_scope: string.quoted.other.lt-gt.include.c++
            - match: '>'
              scope: punctuation.definition.string.end.c++
              pop: true
