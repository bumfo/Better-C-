%YAML 1.2
---
# http://www.sublimetext.com/docs/3/syntax.html
name: C Better
file_extensions:
  - c
  - h
first_line_match: "-[*]-( Mode:)? C -[*]-"
scope: source.c11

variables:
  c99_keywords: 'auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|restrict|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|_Bool|_Complex|_Imaginary'
  identifier: '\b[[:alpha:]_][[:alnum:]_]*\b'
  basic_types: 'void|char|short|int|long|float|double|signed|unsigned|_Bool|_Complex|_Imaginary'
  control_keywords: 'break|case|continue|default|do|else|for|goto|if|return|switch|while'
  storage_classes: 'static|extern|auto|register'
  type_qualifier: 'const|volatile'
  compiler_directive: 'inline|restrict|__restrict__|__restrict'
  modifiers: '{{storage_classes}}|{{type_qualifier}}|{{compiler_directive}}'
  struct_like: 'struct|union'
  if_like_keywords: 'if|switch|while'
  maybe_decl_lookahead: '(?={{identifier}}[\s\*][[:alpha:]_\s\*][[:alnum:]_\s\*]*(?>\[|,|;|=))'
  maybe_function_decl_lookahead: '(?={{identifier}}[\s\*]+[[:alpha:]_][[:alnum:]_\s\*]*(?>\[|\(|,|;|=))'

contexts:
  main:
    - include: global

  global:
    - include: start-of-statement-global
    - include: typedef
    - include: declaration-global-aggressive
    - include: statements

  start-of-statement:
    - match: (?<=;|\{|\})
      push: start-of-statement-context

  start-of-statement-global:
    - match: (?<=;|\{|\})
      push: start-of-statement-context-global

  start-of-statement-context:
    - meta_scope: meta.start-of-statement-context
    - scope: punctuation.terminator.c
      match: ';'
    - match: (?=#)
      pop: true
    - include: comments
    - include: if-like-statement
    - include: for-statement
    - scope: keyword.control.return.c
      match: 'return'
      push: 
        - meta_scope: meta.statement.return.c
        - include: expressions
        - match: '(?=\S)'
          pop: true
    - scope: keyword.control.c
      match: '\b({{control_keywords}})\b'
    - include: typedef
    - include: declaration
    - scope: meta.maybe-declaration-context
      match: '{{maybe_function_decl_lookahead}}'
      push: maybe-declaration-context
    - match: (?<=;|\{|\})(?=\S)
      set:
        - meta_scope: meta.wait-rest-statement
        - match: (?=\S)
          pop: true
        - include: rest-statement
    - match: (?=\S)
      pop: true

  start-of-statement-context-global:
    - meta_scope: meta.start-of-statement-context-global
    - include: declaration-global-aggressive
    - include: start-of-statement-context

  rest-statement:
    - scope: keyword.control.c
      match: '\b({{control_keywords}})\b'
    - scope: punctuation.terminator.c
      match: ';'
    - scope: punctuation.section.block.end.unmatched.c
      match: '\}'
    - scope: punctuation.section.block.begin.c
      match: '\{'
      push:
        - meta_scope: meta.block.c
        - scope: punctuation.section.block.end.c
          match: '\}'
          pop: true
        - include: statements
    - include: expressions

  statements:
    - include: preprocessor
    - include: start-of-statement
    - include: rest-statement

  statements-inline:
    - include: inline-escape
    - include: start-of-statement
    - scope: keyword.control.c
      match: '\b({{control_keywords}})\b'
    - scope: punctuation.terminator.c
      match: ';'
    - scope: punctuation.section.block.end.unmatched.c
      match: '\}'
    - scope: punctuation.section.block.begin.c
      match: '\{'
      push:
        - meta_scope: meta.block.inline.c
        - include: inline-escape
        - scope: punctuation.section.block.end.c
          match: '\}'
          pop: true
        - include: statements-inline
    - include: expressions-inline

  statements-preprocessor:
    - include: preprocessor
    - include: start-of-statement
    - scope: keyword.control.c
      match: '\b({{control_keywords}})\b'
    - scope: punctuation.terminator.c
      match: ';'
    - scope: punctuation.section.block.end.unmatched.c
      match: '\}'
    - scope: punctuation.section.block.begin.c
      match: '\{'
      push:
        - meta_scope: meta.block.preprocessor.c
        - match: '(?=^\s*#\s*(?>e(?>l(?>if|se)|ndif)))'
          pop: true
        - scope: punctuation.section.block.end.c
          match: '\}'
          pop: true
        - include: statements-preprocessor
    - include: expressions

  statements-preprocessor-global:
    - include: declaration-global
    - include: statements-preprocessor

  if-like-statement:
    - scope: keyword.control.with-expression.c
      match: '\b({{if_like_keywords}})\b'
      push:
        - scope: punctuation.section.parens.control.begin.c
          match: '\('
          set:
            - meta_scope: meta.parens.control.c
            - scope: punctuation.section.parens.control.end.c
              match: '\)'
              pop: true
            - include: expressions
        - match: '(?=\S)'
          pop: true

  for-statement:
    - scope: keyword.control.with-expression.c
      match: '\b(for)\b'
      push:
        - scope: punctuation.section.parens.control.begin.c
          match: '\('
          set:
            - meta_scope: meta.parens.control.c
            - include: declaration
            - scope: punctuation.terminator.c
              match: ';'
            - scope: punctuation.section.parens.control.end.c
              match: '\)'
              pop: true
            - include: expressions
        - match: '(?=\S)'
          pop: true

  typedef:
    - scope: keyword.typedef.c
      match: '\btypedef\b'
      push: type-context-typedef

  maybe-declaration-context:
    - meta_scope: meta.maybe-declaration-context
    - scope: storage.type.pointer.maybe.c
      match: '\*'
    - scope: keyword.operator.initializer.maybe.c
      match: '\='
      set:
        - match: '(?=;)'
          pop: true
        - scope: punctuation.separator.declarator.c
          match: ','
          set: after-type-context
        - include: expressions
        - match: (?=\S)
          pop: true
    - scope: punctuation.separator.declarator.c
      match: ','
      set: after-type-context
    - scope: storage.modifier.c
      match: '\b({{modifiers}})\b'
      set: after-type-context
    - scope: storage.type.c
      match: '\b({{basic_types}})\b'
      set: after-type-context
    - scope: entity.name.variable.maybe.c
      match: '{{identifier}}(?=\s*(?>,|=|;))'
    - scope: entity.name.variable.maybe.c
      match: '{{identifier}}(?=\s*(?>\[))'
      set: after-declexpr-context
    - scope: entity.name.function.forward-decl.maybe.c
      match: '{{identifier}}(?=\s*(?>\())'
      set: after-declexpr-context
    - scope: storage.type.maybe.c
      match: '{{identifier}}'
    - match: '(?=\S)'
      pop: true

  declaration:
    - scope: storage.modifier.c
      match: '\b({{modifiers}})\b'
      push: type-context
    - scope: storage.type.struct.c
      match: '\b({{struct_like}})\b'
      push: struct-lookahead-context
    - scope: storage.type.c
      match: '\b({{basic_types}})\b'
      push: after-type-context

  declaration-global:
    - scope: storage.modifier.c
      match: '\b({{modifiers}})\b'
      push: type-context-global
    - scope: storage.type.struct.c
      match: '\b({{struct_like}})\b'
      push: struct-lookahead-context-global
    - scope: storage.type.c
      match: '\b({{basic_types}})\b'
      push: after-type-context-global

  declaration-global-aggressive:
    - include: declaration-global
    - scope: entity.name.function.implicitly.ansi.c
      match: '{{identifier}}(?=\s*\()'
      push: after-declexpr-context
    - match: '(?!\b({{control_keywords}}|typedef)\b)(?={{identifier}})'
      push: type-context-global

  declaration-inline:
    - scope: storage.modifier.c
      match: '\b({{modifiers}})\b'
      push: type-context-inline
    - scope: storage.type.struct.c
      match: '\b({{struct_like}})\b'
      push: struct-lookahead-context-inline
    - scope: storage.type.c
      match: '\b({{basic_types}})\b'
      push: after-type-context-inline

  type-context-common:
    - include: comments
    - scope: storage.modifier.c
      match: '\b({{modifiers}})\b'

  type-context:
    - meta_content_scope: meta.type-context
    - include: type-context-common
    - scope: storage.type.struct.c
      match: '\b({{struct_like}})\b'
      set: struct-lookahead-context
    - scope: storage.type.c
      match: '\b({{basic_types}})\b'
      set: after-type-context
    - scope: storage.type.any.c #meta.
      match: '{{identifier}}'
      set: after-type-context
    - match: (?=\S)
      pop: true

  type-context-typedef:
    - meta_content_scope: meta.type-context-typedef
    - include: type-context-common
    - scope: storage.type.struct.c
      match: '\b({{struct_like}})\b'
      set: struct-lookahead-context-typedef
    - scope: storage.type.c
      match: '\b({{basic_types}})\b'
      set: after-type-context-typedef
    - scope: storage.type.any.c #meta.
      match: '{{identifier}}'
      set: after-type-context-typedef
    - match: (?=\S)
      pop: true

  type-context-global:
    - meta_content_scope: meta.type-context-global
    - include: type-context-common
    - scope: storage.type.struct.c
      match: '\b({{struct_like}})\b'
      set: struct-lookahead-context-global
    - scope: storage.type.c
      match: '\b({{basic_types}})\b'
      set: after-type-context-global
    - scope: meta.maybe-declaration-context
      match: '{{maybe_function_decl_lookahead}}'
      set:
        - scope: storage.type.any.c
          match: '{{identifier}}'
          set: after-type-context-global
    - scope: meta.storage.type.maybe.c
      match: '{{identifier}}'
      set: after-type-context-global
    - match: (?=\S)
      pop: true

  type-context-param:
    - meta_content_scope: meta.type-context-param
    - include: type-context-common
    - scope: storage.type.struct.c
      match: '\b({{struct_like}})\b'
      set:
        - scope: meta.struct-tag.c
          match: '{{identifier}}'
          set: after-type-context-param
        - match: '(?=\S)'
          pop: true
    - scope: storage.type.c
      match: '\b({{basic_types}})\b'
      set: after-type-context-param
    - scope: storage.type.any.c #meta.
      match: '{{identifier}}'
      set: after-type-context-param
    - match: (?=\S)
      pop: true

  type-context-inline:
    - meta_content_scope: meta.type-context-inline
    - include: type-context-common
    - scope: storage.type.struct.c
      match: '\b({{struct_like}})\b'
      set: struct-lookahead-context
    - scope: storage.type.c
      match: '\b({{basic_types}})\b'
      set: after-type-context-inline
    - scope: storage.type.any.c #meta.
      match: '{{identifier}}'
      set: after-type-context-inline
    - match: (?=\S)
      pop: true

  initializer:
    - scope: punctuation.definition.braces.initializer.begin.c
      match: '\{'
      push:
        - meta_scope: meta.initializer.c
        - scope: punctuation.separator.initializer.c
          match: ','
        - scope: punctuation.definition.braces.initializer.end.c
          match: '\}'
          pop: true
        - include: expressions
        - match: '(?=\S)'
          pop: true

  initializer-inline:
    - scope: punctuation.definition.braces.initializer.begin.c
      match: '\{'
      push:
        - meta_scope: meta.initializer.inline.c
        - include: inline-escape
        - scope: punctuation.separator.initializer.c
          match: ','
        - scope: punctuation.definition.braces.initializer.end.c
          match: '\}'
          pop: true
        - include: expressions-inline
        - match: '(?=\S)'
          pop: true

  sizeof:
    - scope: keyword.operator.word.sizeof.c
      match: '\bsizeof\b'
      push:
        - scope: punctuation.section.parens.operator.begin.c
          match: '\('
          set:
            - include: types
            - scope: punctuation.section.parens.operator.end.c
              match: '\)'
              pop: true
            - include: expressions
        - match: '(?=\S)'
          pop: true

  types:
    - scope: storage.modifier.c
      match: '\b({{modifiers}})\b'
      push: type-context
    - scope: storage.type.struct.c
      match: '\b({{struct_like}})\b'
      push: struct-lookahead-context
    - scope: storage.type.c
      match: '\b({{basic_types}})\b'
      push: after-type-context
    - scope: punctuation.definition.brackets.subscriptor.begin.c
      match: '\['
      push: subscriptor-context

  cast-types:
    - scope: storage.modifier.cast.c
      match: '\b({{modifiers}})\b'
      push: type-context
    - scope: storage.type.struct.cast.c
      match: '\b({{struct_like}})\b'
      push: struct-lookahead-context
    - scope: storage.type.cast.c
      match: '\b({{basic_types}})\b'
      push: after-type-context
    - scope: punctuation.definition.brackets.subscriptor.begin.c
      match: '\['
      push: subscriptor-context

  expressions-common:
    - include: comments
    - scope: punctuation.accessor.c
      match: '\.'
    - scope: punctuation.accessor.c
      match: '->'
    - scope: keyword.operator.c
      match: '[+\-*/%!&|\^=<>?:]'
    - include: sizeof
    - scope: keyword.operator.comma.c # punctuation.separator.c
      match: ','
    - include: numbers
    - include: strings
    - include: constants
    - include: control-keyword-escape

  expressions:
    - include: expressions-common
    - scope: meta.identifier-lookahead
      match: '(?={{identifier}})'
      push: identifier-context
    - scope: punctuation.section.group.begin.c
      match: '\('
      push:
        - meta_scope: meta.group.c
        - scope: punctuation.section.group.end.c
          match: '\)'
          set: after-group-context
        - include: cast-types
        - include: expressions
        - match: '(?=\S)'
          pop: true
    - include: initializer

  expressions-inline:
    - include: expressions-common
    - scope: meta.identifier-lookahead
      match: '(?={{identifier}})'
      push: identifier-context-inline
    - scope: punctuation.section.group.begin.c
      match: '\('
      push:
        - meta_scope: meta.group.inline.c
        - include: inline-escape
        - scope: punctuation.section.group.end.c
          match: '\)'
          set: after-group-context-inline
        - include: cast-types
        - include: expressions-inline
        - match: '(?=\S)'
          pop: true
    - include: initializer-inline

  struct-lookahead-context:
    - meta_content_scope: meta.struct-lookahead-context
    - scope: entity.name.struct.forward-decl.c
      match: '{{identifier}}(?=\s*;)'
      pop: true
    - scope: entity.name.struct.c
      match: '{{identifier}}(?=\s*\{)'
      set: struct-declarator-context
    - scope: meta.struct-tag.c
      match: '{{identifier}}'
      set: after-type-context
    - match: (?=\s*\{)
      set: struct-declarator-context
    - match: (?=\S)
      pop: true

  struct-lookahead-context-typedef:
    - meta_content_scope: meta.struct-lookahead-context-typedef
    - scope: entity.name.struct.forward-decl.c
      match: '{{identifier}}(?=\s*;)'
      pop: true
    - scope: entity.name.struct.c
      match: '{{identifier}}(?=\s*\{)'
      set: struct-declarator-context-typedef
    - scope: meta.struct-tag.c
      match: '{{identifier}}'
      set: after-type-context-typedef
    - match: (?=\s*\{)
      set: struct-declarator-context-typedef
    - match: (?=\S)
      pop: true

  struct-lookahead-context-global:
    - meta_content_scope: meta.struct-lookahead-context-global
    - match: '(?=\b({{basic_types}})\b)'
      pop: true
    - scope: entity.name.struct.forward-decl.c
      match: '{{identifier}}(?=\s*;)'
      pop: true
    - scope: entity.name.struct.c
      match: '{{identifier}}(?=\s*\{)'
      set: struct-declarator-context-global
    - scope: meta.struct-tag.c
      match: '{{identifier}}'
      set: after-type-context-global
    - match: (?=\s*\{)
      set: struct-declarator-context-global
    - match: (?=\S)
      pop: true

  struct-lookahead-context-inline:
    - meta_content_scope: meta.struct-lookahead-context-inline
    - scope: entity.name.struct.forward-decl.c
      match: '{{identifier}}(?=\s*;)'
      pop: true
    - scope: entity.name.struct.c
      match: '{{identifier}}(?=\s*\{)'
      set: struct-declarator-context-inline
    - scope: meta.struct-tag.c
      match: '{{identifier}}'
      set: after-type-context-inline
    - match: (?=\s*\{)
      set: struct-declarator-context-inline
    - match: (?=\S)
      pop: true

  struct-declarator-list:
    - scope: punctuation.terminator.c
      match: ';'
    - scope: punctuation.separator.bit-field.c
      match: ':'
      push:
        - include: numbers
        - match: '(?=\S)'
          pop: true
    - include: declaration
    - scope: meta.maybe-declaration-context
      match: '{{maybe_decl_lookahead}}'
      push: maybe-declaration-context
    - match: '(?={{identifier}})'
      push: type-context

  struct-declarator-context:
    - scope: punctuation.section.braces.struct.begin.c
      match: '\{'
      set:
        - meta_scope: meta.struct-declarator-context
        - include: comments
        - include: struct-declarator-list
        - scope: punctuation.section.braces.struct.end.c
          match: '\}'
          set: after-type-context
    - match: (?=\S)
      pop: true

  struct-declarator-context-typedef:
    - scope: punctuation.section.braces.struct.begin.c
      match: '\{'
      set:
        - meta_scope: meta.struct-declarator-context
        - include: comments
        - include: struct-declarator-list
        - scope: punctuation.section.braces.struct.end.c
          match: '\}'
          set: after-type-context-typedef
    - match: (?=\S)
      pop: true

  struct-declarator-context-global:
    - scope: punctuation.definition.braces.struct.begin.c
      match: '\{'
      set:
        - meta_scope: meta.struct-declarator-context-global
        - include: comments
        - include: struct-declarator-list
        - scope: punctuation.definition.braces.struct.end.c
          match: '\}'
          set: after-type-context-global
    - match: (?=\S)
      pop: true

  struct-declarator-context-inline:
    - scope: punctuation.definition.braces.struct.begin.c
      match: '\{'
      set:
        - meta_scope: meta.struct-declarator-context-inline
        - include: comments
        - include: struct-declarator-list
        - scope: punctuation.definition.braces.struct.end.c
          match: '\}'
          set: after-type-context-inline
    - match: (?=\S)
      pop: true

  struct-declarator-context-param:
    - scope: punctuation.definition.braces.struct.begin.c
      match: '\{'
      set:
        - meta_scope: meta.struct-declarator-context-param
        - include: comments
        - include: struct-declarator-list
        - scope: punctuation.definition.braces.struct.end.c
          match: '\}'
          set: after-type-context-param
    - match: (?=\S)
      pop: true

  identifier-context:
    - meta_content_scope: meta.identifier-context
    - include: comments
    - scope: variable.function.c
      match: '{{identifier}}(?=\s*\()'
      set: after-expr-context
    - scope: meta.identifier.c
      match: '{{identifier}}'
      set: after-expr-context

  identifier-context-inline:
    - meta_content_scope: meta.identifier-context-inline
    - include: comments
    - scope: variable.function.c
      match: '{{identifier}}(?=\s*\()'
      set: after-expr-context-inline
    - scope: meta.identifier.c
      match: '{{identifier}}'
      set: after-expr-context-inline

  declarator-common:
    - include: comments
    - scope: storage.type.pointer.c
      match: '\*'
    - scope: storage.type.c
      match: '\b({{basic_types}})\b'
    - scope: storage.modifier.c
      match: '\b({{modifiers}})\b'
    - include: control-keyword-escape

  declarator:
    - meta_content_scope: meta.declexpr-context
    - include: declarator-common
    - scope: punctuation.section.parens.begin.c
      match: '\('
      push: declexpr-parens-context

  declarator-typedef:
    - meta_content_scope: meta.declexpr-context-typedef
    - include: declarator-common
    - scope: punctuation.section.parens.begin.c
      match: '\('
      push: declexpr-parens-context-typedef

  declarator-global:
    - meta_content_scope: meta.declexpr-context-global
    - include: declarator-common
    - scope: punctuation.section.parens.begin.c
      match: '\('
      push: declexpr-parens-context-global

  declarator-param:
    - meta_content_scope: meta.declexpr-context-param
    - include: declarator-common
    - scope: punctuation.section.parens.begin.c
      match: '\('
      push: declexpr-parens-context-param

  declarator-inline:
    - meta_content_scope: meta.declexpr-context-inline
    - include: inline-escape
    - include: declarator-common
    - scope: punctuation.section.parens.begin.c
      match: '\('
      push: declexpr-parens-context-inline

  declarator-param-inline:
    - meta_content_scope: meta.declexpr-context-param-inline
    - include: declarator-common
    - scope: punctuation.section.parens.begin.c
      match: '\('
      push: declexpr-parens-context-param

  control-keyword-escape:
    - match: '(?=\b({{control_keywords}})\b)'
      pop: true

  after-type-context:
    - meta_content_scope: meta.after-type-context
    - include: declarator
    - scope: entity.name.function.forward-decl.c
      match: '{{identifier}}(?=\s*\(.+;)'
      set: after-declexpr-context
    - scope: entity.name.variable.c
      match: '{{identifier}}'
      set: after-declexpr-context
    - match: (?=\S)
      pop: true

  after-type-context-typedef:
    - meta_content_scope: meta.after-type-context-typedef
    - include: declarator-typedef
    - scope: entity.name.type.typedef.function.c
      match: '{{identifier}}(?=\s*\(.+;)'
      set: after-declexpr-context
    - scope: entity.name.type.typedef.c
      match: '{{identifier}}'
      set: after-declexpr-context
    - match: (?=\S)
      pop: true

  after-type-context-global:
    - meta_content_scope: meta.after-type-context-global
    - include: declarator-global
    - scope: entity.name.function.forward-decl.c
      match: '{{identifier}}(?=\s*\(.+;)'
      set: after-declexpr-context
    - scope: entity.name.function.c
      match: '{{identifier}}(?=\s*\()'
      set: after-declexpr-context
    - scope: entity.name.variable.c
      match: '{{identifier}}'
      set: after-declexpr-context
    - match: (?=\S)
      pop: true

  after-type-context-param:
    - meta_content_scope: meta.after-type-context-param
    - include: declarator-param
    - scope: variable.parameter.c
      match: '{{identifier}}'
      set: after-declexpr-context-param
    - match: (?=\S)
      pop: true

  after-type-context-inline:
    - meta_content_scope: meta.after-type-context-inline
    - include: declarator-inline
    - scope: entity.name.variable.c
      match: '{{identifier}}'
      set: after-declexpr-context-inline
    - match: (?=\S)
      pop: true

  after-type-context-param-inline:
    - meta_content_scope: meta.after-type-context-param-inline
    - include: declarator-param-inline
    - scope: variable.parameter.c
      match: '{{identifier}}'
      set: after-declexpr-context-param-inline
    - match: (?=\S)
      pop: true

  after-type-context-fake:
    - meta_content_scope: meta.after-type-context-param
    - include: declarator
    - scope: meta.variable.parameter.c
      match: '{{identifier}}'
      set: after-declexpr-context-param-fake
    - match: (?=\S)
      pop: true

  declexpr-parens-context-common:
    - include: comments

  declexpr-parens-context:
    - meta_content_scope: meta.declexpr-parens-context
    - include: declexpr-parens-context-common
    - include: declarator
    - scope: entity.name.variable.c
      match: '{{identifier}}'
      push: after-declexpr-context
    - scope: punctuation.section.parens.end.c
      match: '\)'
      set: after-declexpr-context-fake

  declexpr-parens-context-typedef:
    - meta_content_scope: meta.declexpr-parens-context-typedef
    - include: declexpr-parens-context-common
    - include: declarator-typedef
    - scope: entity.name.type.typedef.c
      match: '{{identifier}}'
      push: after-declexpr-context
    - scope: punctuation.section.parens.end.c
      match: '\)'
      set: after-declexpr-context-fake

  declexpr-parens-context-global:
    - meta_content_scope: meta.declexpr-parens-context-global
    - include: declexpr-parens-context-common
    - include: declarator-global
    - scope: entity.name.function.c
      match: '{{identifier}}(?=\s*\()'
      push: after-declexpr-context
    - scope: entity.name.variable.c
      match: '{{identifier}}'
      push: after-declexpr-context
    - scope: punctuation.section.parens.end.c
      match: '\)'
      set: after-declexpr-context-fake

  declexpr-parens-context-param:
    - meta_content_scope: meta.declexpr-parens-context-param
    - include: declexpr-parens-context-common
    - include: declarator-param
    - scope: variable.parameter.c
      match: '{{identifier}}'
      push: after-declexpr-context
    - scope: punctuation.section.parens.end.c
      match: '\)'
      set: after-declexpr-context-fake

  declexpr-parens-context-inline:
    - meta_content_scope: meta.declexpr-parens-context-inline
    - include: inline-escape
    - include: declexpr-parens-context-common
    - include: declarator-inline
    - scope: entity.name.variable.c
      match: '{{identifier}}'
      push: after-declexpr-context
    - scope: punctuation.section.parens.end.c
      match: '\)'
      set: after-declexpr-context-fake

  typeless-parens:
    - scope: punctuation.section.parens.begin.c
      match: '\('
      push: declexpr-parens-context

  decl-initializer:
    - scope: keyword.operator.initializer.c
      match: '\='
      push:
        - match: '(?=,|;)'
          pop: true
        - include: expressions
        - match: (?=\S)
          pop: true

  decl-initializer-inline:
    - scope: keyword.operator.initializer.c
      match: '\='
      push:
        - match: '(?=,|;)'
          pop: true
        - include: expressions-inline
        - match: (?=\S)
          pop: true

  after-declexpr-context:
    - meta_content_scope: meta.after-declexpr-context
    - include: comments
    - match: '(?<=\))'
      set: after-declexpr-context-fake
    - scope: punctuation.definition.brackets.subscriptor.begin.c
      match: '\['
      push: subscriptor-context
    - scope: punctuation.definition.parens.parameters.begin.c
      match: '\('
      push: parameters-context
    - include: decl-initializer
    - scope: punctuation.separator.declarator.c
      match: ','
      set: after-type-context
    - match: '(?=\S)'
      pop: true

  after-declexpr-context-fake:
    - meta_content_scope: meta.after-declexpr-context-fake
    - include: comments
    - scope: punctuation.definition.brackets.subscriptor.begin.c
      match: '\['
      push: subscriptor-context
    - scope: punctuation.definition.parens.parameters.begin.c
      match: '\('
      push: parameters-context-fake
    - include: decl-initializer
    - scope: punctuation.separator.declarator.c
      match: ','
      set: after-type-context
    - match: '(?=\S)'
      pop: true

  after-declexpr-context-param:
    - meta_content_scope: meta.after-declexpr-context-param
    - include: comments
    - match: '(?<=\))'
      set: after-declexpr-context-fake
    - scope: punctuation.definition.brackets.subscriptor.begin.c
      match: '\['
      push: subscriptor-context
    - scope: punctuation.definition.parens.parameters.begin.c
      match: '\('
      push: parameters-context
    # - include: decl-initializer
    - match: '(?=\S)'
      pop: true

  after-declexpr-context-param-fake:
    - meta_content_scope: meta.after-declexpr-context-param-fake
    - include: comments
    - match: '(?<=\))'
      set: after-declexpr-context-fake
    - scope: punctuation.definition.brackets.subscriptor.begin.c
      match: '\['
      push: subscriptor-context
    - scope: punctuation.definition.parens.parameters.begin.c
      match: '\('
      push: parameters-context-fake
    # - include: decl-initializer
    - match: '(?=\S)'
      pop: true

  after-declexpr-context-inline:
    - meta_content_scope: meta.after-declexpr-context-inline
    - include: inline-escape
    - include: comments
    - match: '(?<=\))'
      set: after-declexpr-context-fake-inline
    - scope: punctuation.definition.brackets.subscriptor.begin.c
      match: '\['
      push: subscriptor-context-inline
    - scope: punctuation.definition.parens.parameters.begin.c
      match: '\('
      push: parameters-context-inline
    - include: decl-initializer
    - scope: punctuation.separator.declarator.c
      match: ','
      set: after-type-context-inline
    - match: '(?=\S)'
      pop: true

  after-declexpr-context-fake-inline:
    - meta_content_scope: meta.after-declexpr-context-fake-inline
    - include: comments
    - scope: punctuation.definition.brackets.subscriptor.begin.c
      match: '\['
      push: subscriptor-context-inline
    - scope: punctuation.definition.parens.parameters.begin.c
      match: '\('
      push: parameters-context-fake-inline
    - include: decl-initializer
    - scope: punctuation.separator.declarator.c
      match: ','
      set: after-type-context-inline
    - match: '(?=\S)'
      pop: true

  after-declexpr-context-param-inline:
    - meta_content_scope: meta.after-declexpr-context-inline
    - include: inline-escape
    - include: comments
    - match: '(?<=\))'
      set: after-declexpr-context-fake-inline
    - scope: punctuation.definition.brackets.subscriptor.begin.c
      match: '\['
      push: subscriptor-context-inline
    - scope: punctuation.definition.parens.parameters.begin.c
      match: '\('
      push: parameters-context-inline
    # - include: decl-initializer
    - match: '(?=\S)'
      pop: true

  parameters-context-common:
    - include: comments
    - scope: punctuation.definition.variadic.c
      match: '\.\.\.'
    - scope: punctuation.definition.parens.parameters.end.c
      match: '\)'
      pop: true
    - scope: punctuation.separator.parameter.c
      match: ','

  parameters-context:
    - meta_content_scope: meta.parameters-context
    - include: parameters-context-common
    - scope: storage.type.struct.c
      match: '\b({{struct_like}})\b'
      push: struct-declarator-context-param
    - scope: storage.type.c
      match: '\b({{basic_types}})\b'
      push: after-type-context-param
    - scope: storage.modifier.c
      match: '\b({{modifiers}})\b'
      push: type-context-param
    # - scope: storage.type.maybe.c
    #   match: '{{identifier}}(?=\s*\*|\s+[[:alpha:]_]|\s*\(\s*\*)'
    #   push: after-type-context-param
    - scope: storage.type.any.c
      match: '{{identifier}}'
      push: after-type-context-param
    - include: typeless-parens
    - match: \{|(?=;)
      pop: true

  parameters-context-fake:
    - meta_content_scope: meta.parameters-context-fake
    - include: parameters-context-common
    - scope: storage.type.struct.c
      match: '\b({{struct_like}})\b'
      push: struct-declarator-context
    - scope: storage.type.c
      match: '\b({{basic_types}})\b'
      push: after-type-context
    - scope: storage.modifier.c
      match: '\b({{modifiers}})\b'
      push: type-context
    - scope: storage.type.any.c
      match: '{{identifier}}'
      push: after-type-context-fake
    - include: typeless-parens
    - match: \{|(?=;)
      pop: true

  parameters-context-inline:
    - meta_content_scope: meta.parameters-context-inline
    - include: parameters-context-common
    - scope: storage.type.struct.c
      match: '\b({{struct_like}})\b'
      push: struct-declarator-context-inline
    - scope: storage.type.c
      match: '\b({{basic_types}})\b'
      push: after-type-context-param-inline
    - scope: storage.modifier.c
      match: '\b({{modifiers}})\b'
      push: type-context-param
    - scope: storage.type.any.c
      match: '{{identifier}}'
      push: after-type-context-param-inline
    - include: typeless-parens
    - match: \{|(?=;)
      pop: true

  parameters-context-fake-inline:
    - meta_content_scope: meta.parameters-context-fake-inline
    - include: parameters-context-common
    - scope: storage.type.struct.c
      match: '\b({{struct_like}})\b'
      push:
        - scope: meta.struct-tag.c
          match: '{{identifier}}'
          set: after-type-context-inline
        - match: '(?=\S)'
          pop: true
    - scope: storage.type.c
      match: '\b({{basic_types}})\b'
      push: after-type-context-inline
    - scope: storage.modifier.c
      match: '\b({{modifiers}})\b'
      push: type-context
    - scope: storage.type.any.c
      match: '{{identifier}}'
      push: after-type-context-inline
    - include: typeless-parens
    - match: \{|(?=;)
      pop: true

  after-group-context:
    - include: initializer
    - include: after-expr-context

  after-group-context-inline:
    - include: initializer-inline
    - include: after-expr-context-inline

  after-expr-context:
    - meta_content_scope: meta.after-expr-context
    - include: comments
    - scope: punctuation.definition.brackets.subscriptor.begin.c
      match: '\['
      push: subscriptor-context
    - scope: punctuation.section.parens.arguments.begin.c
      match: '\('
      push: arguments-context
    - match: '(?=\S)'
      pop: true

  after-expr-context-inline:
    - meta_content_scope: meta.after-expr-context-inline
    - include: inline-escape
    - include: comments
    - scope: punctuation.definition.brackets.subscriptor.begin.c
      match: '\['
      push: subscriptor-context-inline
    - scope: punctuation.section.parens.arguments.begin.c
      match: '\('
      push: arguments-context-inline
    - match: '(?=\S)'
      pop: true

  arguments-context:
    - scope: punctuation.separator.arguments.c
      match: ','
    - scope: punctuation.section.parens.arguments.end.c
      match: '\)'
      pop: true
    - include: types
    - include: expressions
    - match: (?=\S)
      pop: true

  arguments-context-inline:
    - include: inline-escape
    - scope: punctuation.separator.arguments.c
      match: ','
    - scope: punctuation.section.parens.arguments.end.c
      match: '\)'
      pop: true
    - include: types
    - include: expressions
    - match: (?=\S)
      pop: true

  subscriptor-context:
    - scope: punctuation.definition.brackets.subscriptor.end.c
      match: '\]'
      pop: true
    - include: expressions
    - match: '(?=\S)'
      pop: true

  subscriptor-context-inline:
    - include: inline-escape
    - scope: punctuation.definition.brackets.subscriptor.end.c
      match: '\]'
      pop: true
    - include: expressions
    - match: '(?=\S)'
      pop: true

  strings:
    - include: scope:source.c#strings

  simple-chars:
    - scope: punctuation.definition.string.begin.c
      match: "'"
      push:
        - meta_scope: string.quoted.single.c
        - scope: punctuation.definition.string.end.c
          match: "'"
          pop: true
        - include: scope:source.c#string_escaped_char

  numbers:
    - include: scope:source.c#numbers

  constants:
    - scope: constant.language.c
      match: \b(NULL|true|false|TRUE|FALSE)\b

  comments:
    - scope: comment.block.c
      match: ^/\* =(\s*.*?)\s*= \*/$\n?
      captures:
        1: meta.toc-list.banner.block.c
    - scope: punctuation.definition.comment.c
      match: /\*
      push:
        - meta_scope: comment.block.c
        - scope: punctuation.definition.comment.c
          match: \*/
          pop: true
    - scope: invalid.illegal.stray-comment-end.c
      match: \*/(?!\*)
    - scope: comment.line.banner.c
      match: ^// =(\s*.*?)\s*=\s*$\n?
      captures:
        1: meta.toc-list.banner.line.c
    - scope: punctuation.definition.comment.c
      match: //
      push:
        - meta_scope: comment.line.double-slash.c
        - match: '(\\)$\n'
          captures:
            1: punctuation.separator.continuation.c
        - match: (?=\n)
          pop: true

  preprocessor:
    - include: incomplete-inc
    - include: preprocessor-include
    - include: preprocessor-define
    - include: preprocessor-condition
    - include: preprocessor-error

  incomplete-inc:
    - scope: meta.preprocessor.incomplete.c
      match: '^\s*(#i(nc?)?)\b\s*'

  preprocessor-include:
    - scope: meta.preprocessor.include.c keyword.control.import.include.c
      match: '^\s*#\s*include\b\s*'
      push:
        - meta_scope: meta.preprocessor.include.c
        - scope: punctuation.definition.string.begin.c
          match: '"'
          push:
            - meta_scope: string.quoted.double.include.c
            - scope: punctuation.definition.string.end.c
              match: '"'
              pop: true
        - scope: punctuation.definition.string.begin.c
          match: '<'
          push:
            - meta_scope: string.quoted.other.lt-gt.include.c
            - scope: punctuation.definition.string.end.c
              match: '>'
              pop: true
        - match: (?=\n)
          pop: true

  preprocessor-define:
    - scope: meta.preprocessor.macro.c keyword.control.import.define.c
      match: '^\s*#\s*define\b\s*'
      push:
        - include: inline-escape
        - scope: entity.name.function.preprocessor.c
          match: '{{identifier}}(?=\s*\()'
          set: preprocessor-parameters
        - scope: entity.name.constant.preprocessor.c
          match: '{{identifier}}'
          set: preprocessor-macro-definition

  preprocessor-parameters:
    - scope: punctuation.definition.parens.parameters.begin.c
      match: '\(' 
      set:
        - scope: punctuation.definition.variadic.c
          match: '\.\.\.'
        - scope: punctuation.separator.parameter.c
          match: ','
        - scope: variable.parameter.preprocessor.c
          match: '{{identifier}}'
        - include: plain-group
        - include: inline-escape
        - scope: punctuation.definition.parens.parameters.end.c
          match: '\)'
          set: preprocessor-macro-definition

  preprocessor-macro-definition:
    - meta_content_scope: meta.inline.c
    - include: inline-escape
    - include: statements-inline
    # - include: expressions

  preprocessor-condition:
    - include: preprocessor-if
    - include: preprocessor-ifdef

  preprocessor-if:
    - scope: meta.preprocessor.macro.c keyword.control.import.condition.c
      match: '^\s*#\s*if\b\s*'
      push: preprocessor-if-expr

  preprocessor-elif:
    - scope: meta.preprocessor.macro.c keyword.control.import.condition.c
      match: '^\s*#\s*elif\b\s*'
      set: preprocessor-if-expr

  preprocessor-if-expr:
    - scope: constant.numeric.zero.preprocessor.c
      match: '\b0\b'
      set: preprocessor-always-false
    - scope: constant.numeric.one.preprocessor.c
      match: '\b1\b'
      set: preprocessor-always-true
    - match: '(?=\n)'
      set: preprocessor-waiting-endif
    - include: inline-escape
    - include: numbers
    - include: comments
    - include: simple-chars
    - scope: keyword.operator.c
      match: '[+\-*/&|\^<=>]'

  preprocessor-quote-in-comment:
    - match: "'"
      push:
        - include: inline-escape
        - match: "'"
          pop: true
    - match: '"'
      push:
        - include: inline-escape
        - match: '"'
          pop: true

  preprocessor-always-false:
    - meta_content_scope: comment.block.preprocessor.c
    - match: '(?=^\s*#\s*elif\b)'
      set: preprocessor-if
    - scope: meta.preprocessor.macro.c keyword.control.import.condition.c
      match: '^\s*#\s*else\b'
      set:
        - match: '(?=\n)'
          set: preprocessor-waiting-endif
    - scope: meta.keyword.control.import.condition.c
      match: '^\s*#\s*if(?>n?def)?\b'
      push:
        - match: '(?=\n)'
          set:
            - include: comments
            - include: preprocessor-quote-in-comment
            - scope: meta.keyword.control.import.condition.c
              match: '^\s*#\s*endif\b\s*'
              pop: true
    - include: preprocessor-endif
    - include: comments
    - include: preprocessor-quote-in-comment

  preprocessor-always-true:
    - scope: meta.preprocessor.macro.c keyword.control.import.condition.c
      match: '^\s*#\s*else\b\s*'
      set: preprocessor-always-false
    - include: preprocessor-waiting-endif

  preprocessor-waiting-endif:
    - include: preprocessor-else
    - include: preprocessor-elif
    - include: preprocessor-endif
    - include: statements-preprocessor-global

  preprocessor-ifdef:
    - scope: meta.preprocessor.macro.c keyword.control.import.ifdef.c
      match: '^\s*#\s*ifn?def\b\s*'
      push:
        - match: '(?=\n)'
          set: preprocessor-waiting-endifdef
        - include: inline-escape

  preprocessor-elifdef:
    - scope: meta.preprocessor.macro.c keyword.control.import.elifdef.c
      match: '^\s*#\s*elif\b\s*'
      set: preprocessor-if-expr

  preprocessor-waiting-endifdef:
    - include: preprocessor-else
    - include: preprocessor-elifdef
    - include: preprocessor-endif
    - include: statements-preprocessor-global

  preprocessor-else:
    - scope: meta.preprocessor.macro.c keyword.control.import.condition.c
      match: '^\s*#\s*else\b'
      set: preprocessor-waiting-endif

  preprocessor-endif:
    - scope: meta.preprocessor.macro.c keyword.control.import.condition.c
      match: '^\s*#\s*endif\b\s*'
      pop: true

  preprocessor-error:
    - scope: meta.preprocessor.macro.c keyword.control.import.error.c
      match: '^\s*#\s*(?>error|warning)\b\s*'
      push:
        - match: '(?=")'
          pop: true
        - match: '(?=\S)'
          set:
            - meta_content_scope: string.unquoted.preprocessor.c
            - include: comments
            - include: inline-escape

  inline-escape:
    - match: '(\\)$\n'
      captures:
        1: punctuation.separator.continuation.c
    - match: '(?=\n)'
      pop: true

  plain-group:
    - match: '\('
      push:
        - include: plain-group
        - match: '\)'
          pop: true
